# WirePlumber daemon context configuration #

context.properties = {
  ## Properties to configure the PipeWire context and some modules

  #application.name = WirePlumber
  log.level = 2
  wireplumber.script-engine = lua-scripting
  #wireplumber.export-core = true

  #mem.mlock-all = false
  #support.dbus  = true
}

context.spa-libs = {
  #<factory-name regex> = <library-name>
  #
  # Used to find spa factory names. It maps an spa factory name
  # regular expression to a library name that should contain
  # that factory.
  #
  api.alsa.*      = alsa/libspa-alsa
  api.bluez5.*    = bluez5/libspa-bluez5
  api.v4l2.*      = v4l2/libspa-v4l2
  api.libcamera.* = libcamera/libspa-libcamera
  audio.convert.* = audioconvert/libspa-audioconvert
  support.*       = support/libspa-support
}

context.modules = [
  #{   name = <module-name>
  #    [ args = { <key> = <value> ... } ]
  #    [ flags = [ [ ifexists ] [ nofail ] ]
  #}
  #
  # PipeWire modules to load.
  # If ifexists is given, the module is ignored when it is not found.
  # If nofail is given, module initialization failures are ignored.
  #

  # Uses RTKit to boost the data thread priority.
  { name = libpipewire-module-rt
      args = {
          nice.level   = -11
          #rt.prio      = 88
          #rt.time.soft = -1
          #rt.time.hard = -1
      }
      flags = [ ifexists nofail ]
  }

  # The native communication protocol.
  { name = libpipewire-module-protocol-native }

  # Allows creating nodes that run in the context of the
  # client. Is used by all clients that want to provide
  # data to PipeWire.
  { name = libpipewire-module-client-node }

  # Allows creating devices that run in the context of the
  # client. Is used by the session manager.
  { name = libpipewire-module-client-device }

  # Makes a factory for wrapping nodes in an adapter with a
  # converter and resampler.
  { name = libpipewire-module-adapter }

  # Allows applications to create metadata objects. It creates
  # a factory for Metadata objects.
  { name = libpipewire-module-metadata }

  # Provides factories to make session manager objects.
  { name = libpipewire-module-session-manager }
]

wireplumber.components = [
  #{ name = <component-name>, type = <component-type> }
  #
  # WirePlumber components to load
  #

  # The lua scripting engine
  { name = libwireplumber-module-lua-scripting, type = module }

  # Parses all the wireplumber settings in the .conf file, loads them into a
  # "sm-settings" pipewire metadata and updates the settings to a state file,
  # when persitent behavior is enabled.

  { name = libwireplumber-module-settings, type = module }

  # The lua configuration file(s)
  # Other components are loaded from there
  { name = main.lua, type = config/lua }
  { name = policy.lua, type = config/lua }
  { name = bluetooth.lua, type = config/lua }
]

wireplumber.settings = {
  # These settings and rules will be loaded during bootup.
  #
  # wireplumber JSON settings interface.
  # <name> = <value>
  #
  #
  # wireplumber rule/logic based JSON settings interface.
  # <name> = [
  # {
  #   matches = [
  #     {
  #       <pipewire property2> = <~value*>
  ## if a value starts with "~" then it triggers regular experssion evaluation
  #       <pipewire property1> = <value>
  ## If properties are grouped like this in a single object, that means they
  ## must all must match ("AND" behaviour). If they are in separate objects
  ## with in the same match, then any object is a separate match
  ## ("OR" behaviour).
  #     }
  #     { <wireplumber property> : <value> }
  #     { <wireplumber property> <value> }
  ## "=", ":" or just a space, all are interpreted the same.
  ## Multiple properties matched in a single object are ANDed and across the
  ## objects are ORed
  #   ]
  #   actions = {
  #     update-props = {
  #       <pipewire property> = <value>,
  #       <wireplumber setting> = <value>,
  #     }
  #   }
  # }
  #
  # if "persistent.settings" is true, the settings will be read from conf file
  # only once and for subsequent reboots they will be read from the state files,
  # till the time the setting is set to false.
  #
  persistent.settings = false
  access.enable-flatpak-portal = true
  access = [
    {
      matches = [
        {
          pipewire.access = "flatpak"
          media.category = "Manager"
        }
      ]
      actions = {
        update-props = {
          default_permissions = "all",
        }
      }
    }

    {
      matches = [
        {
          pipewire.access = "flatpak"
        }
      ]
      actions = {
        update-props = {
          default_permissions = "rx",
        }
      }
    }

    {
      matches = [
        {
          pipewire.access = "restricted"
        }
      ]
      actions = {
        update-props = {
          default_permissions = "rx",
        }
      }
    }
  ]
  # store preferences to the file system and restore them at startup;
  # when set to false, default nodes and routes are selected based on
  # their priorities and any runtime changes do not persist after restart
  device.use-persistent-storage = true

  # the default volume to apply to ACP device nodes, in the linear scale
  # default-volume = 0.4

  # Whether to auto-switch to echo cancel sink and source nodes or not
  device.auto-echo-cancel = true

  # Sets the default echo-cancel-sink node name to automatically switch to
  device.echo-cancel-sink-name = echo-cancel-sink

  # Sets the default echo-cancel-source node name to automatically switch to
  device.echo-cancel-source-name = echo-cancel-source

  device = [
    {
      matches = [
          # Matches all devices
          { device.name = "*" }
      ]
      actions = {
        update-props = {
          profile_names = "off pro-audio"
        }
      }
    }
  ]

  stream_default.restore-props = true
  stream_default.restore-target = true
  stream_default = [
    {
      matches = [
          # Matches all devices
          { application.name = "pw-play" }
      ]
      actions = {
        update-props = {
          state.restore-props = false
          state.restore-target = false
        }
      }
    }
  ]
  alsa_monitor.alsa.reserve = true
  alsa_monitor.alsa.midi = true
  alsa_monitor.alsa.monitoring = true

  alsa_monitor = [
    {
      # An array of matches/actions to evaluate.

      # If you want to disable some devices or nodes, you can apply properties per device as the following example.
      # The name can be found by running pw-cli ls Device, or pw-cli dump Device
      # matches = [
      #   {
      #     { device.name = "name_of_some_disabled_card" }
      #   }
      # ]
      # actions = {
      #   update-props = {
      #     device.disabled = true,
      #   }
      # }
    }
    {
      # Rules for matching a device or node. It is an array of
      # properties that all need to match the regexp. If any of the
      # matches work, the actions are executed for the object.
      matches = [
        {
          # This matches all cards.
          device.name = "~alsa_card.*"
        }
      ]
      actions = {
        update-props = {
          #Use ALSA-Card-Profile devices. They use UCM or the profile
          #configuration to configure the device and mixer settings.
          api.alsa.use-acp = true,

          #Use UCM instead of profile when available. Can be
          #disabled to skip trying to use the UCM profile.
          #api.alsa.use-ucm = true

          #Don't use the hardware mixer for volume control. It
          #will only use software volume. The mixer is still used
          #to mute unused paths based on the selected port.
          #api.alsa.soft-mixer = false

          #Ignore decibel settings of the driver. Can be used to
          #work around buggy drivers that report wrong values.
          #api.alsa.ignore-dB = false

          #The profile set to use for the device. Usually this is
          #"default.conf" but can be changed with a udev rule or here.
          #device.profile-set = "profileset-name",

          #The default active profile. Is by default set to "Off".
          #device.profile = "default profile name",

          #Automatically select the best profile. This is the
          #highest priority available profile. This is disabled
          #here and instead implemented in the session manager
          #where it can save and load previous preferences.
          api.acp.auto-profile = false

          #Automatically switch to the highest priority available port.
          #This is disabled here and implemented in the session manager instead.
          api.acp.auto-port = false

          #Other properties can be set here.
          #device.nick = "My Device"
        }
      }
    }

  ]
}
